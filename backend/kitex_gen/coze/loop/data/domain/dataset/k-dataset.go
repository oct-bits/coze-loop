// Code generated by Kitex v0.13.1. DO NOT EDIT.

package dataset

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"

	"github.com/cloudwego/gopkg/protocol/thrift"
	kutils "github.com/cloudwego/kitex/pkg/utils"
)

// unused protection
var (
	_ = fmt.Formatter(nil)
	_ = (*bytes.Buffer)(nil)
	_ = (*strings.Builder)(nil)
	_ = reflect.Type(nil)
	_ = thrift.STOP
)

func (p *DatasetFeatures) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_DatasetFeatures[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *DatasetFeatures) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EditSchema = _field
	return offset, nil
}

func (p *DatasetFeatures) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.RepeatedData = _field
	return offset, nil
}

func (p *DatasetFeatures) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MultiModal = _field
	return offset, nil
}

func (p *DatasetFeatures) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *DatasetFeatures) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *DatasetFeatures) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *DatasetFeatures) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEditSchema() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 1)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.EditSchema)
	}
	return offset
}

func (p *DatasetFeatures) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetRepeatedData() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 2)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.RepeatedData)
	}
	return offset
}

func (p *DatasetFeatures) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMultiModal() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 3)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.MultiModal)
	}
	return offset
}

func (p *DatasetFeatures) field1Length() int {
	l := 0
	if p.IsSetEditSchema() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *DatasetFeatures) field2Length() int {
	l := 0
	if p.IsSetRepeatedData() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *DatasetFeatures) field3Length() int {
	l := 0
	if p.IsSetMultiModal() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *DatasetFeatures) DeepCopy(s interface{}) error {
	src, ok := s.(*DatasetFeatures)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.EditSchema != nil {
		tmp := *src.EditSchema
		p.EditSchema = &tmp
	}

	if src.RepeatedData != nil {
		tmp := *src.RepeatedData
		p.RepeatedData = &tmp
	}

	if src.MultiModal != nil {
		tmp := *src.MultiModal
		p.MultiModal = &tmp
	}

	return nil
}

func (p *Dataset) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetID bool = false
	var issetSpaceID bool = false
	var issetSchemaID bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSpaceID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSchemaID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 16:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField16(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 17:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField17(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 18:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField18(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 19:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField19(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 20:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField20(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 21:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField21(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 22:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField22(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 100:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField100(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 101:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField101(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 102:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField102(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 103:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField103(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 104:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField104(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 150:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField150(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetID {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetSpaceID {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetSchemaID {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_Dataset[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_Dataset[fieldId]))
}

func (p *Dataset) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.ID = _field
	return offset, nil
}

func (p *Dataset) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.AppID = _field
	return offset, nil
}

func (p *Dataset) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.SpaceID = _field
	return offset, nil
}

func (p *Dataset) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.SchemaID = _field
	return offset, nil
}

func (p *Dataset) FastReadField10(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *Dataset) FastReadField11(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Description = _field
	return offset, nil
}

func (p *Dataset) FastReadField12(buf []byte) (int, error) {
	offset := 0

	var _field *DatasetStatus
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := DatasetStatus(v)
		_field = &tmp
	}
	p.Status = _field
	return offset, nil
}

func (p *Dataset) FastReadField13(buf []byte) (int, error) {
	offset := 0

	var _field *DatasetCategory
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := DatasetCategory(v)
		_field = &tmp
	}
	p.Category = _field
	return offset, nil
}

func (p *Dataset) FastReadField14(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.BizCategory = _field
	return offset, nil
}

func (p *Dataset) FastReadField15(buf []byte) (int, error) {
	offset := 0
	_field := NewDatasetSchema()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Schema = _field
	return offset, nil
}

func (p *Dataset) FastReadField16(buf []byte) (int, error) {
	offset := 0

	var _field *SecurityLevel
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := SecurityLevel(v)
		_field = &tmp
	}
	p.SecurityLevel = _field
	return offset, nil
}

func (p *Dataset) FastReadField17(buf []byte) (int, error) {
	offset := 0

	var _field *DatasetVisibility
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := DatasetVisibility(v)
		_field = &tmp
	}
	p.Visibility = _field
	return offset, nil
}

func (p *Dataset) FastReadField18(buf []byte) (int, error) {
	offset := 0
	_field := NewDatasetSpec()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Spec = _field
	return offset, nil
}

func (p *Dataset) FastReadField19(buf []byte) (int, error) {
	offset := 0
	_field := NewDatasetFeatures()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Features = _field
	return offset, nil
}

func (p *Dataset) FastReadField20(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.LatestVersion = _field
	return offset, nil
}

func (p *Dataset) FastReadField21(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.NextVersionNum = _field
	return offset, nil
}

func (p *Dataset) FastReadField22(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ItemCount = _field
	return offset, nil
}

func (p *Dataset) FastReadField100(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.CreatedBy = _field
	return offset, nil
}

func (p *Dataset) FastReadField101(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.CreatedAt = _field
	return offset, nil
}

func (p *Dataset) FastReadField102(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.UpdatedBy = _field
	return offset, nil
}

func (p *Dataset) FastReadField103(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.UpdatedAt = _field
	return offset, nil
}

func (p *Dataset) FastReadField104(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ExpiredAt = _field
	return offset, nil
}

func (p *Dataset) FastReadField150(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ChangeUncommitted = _field
	return offset, nil
}

func (p *Dataset) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *Dataset) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField21(buf[offset:], w)
		offset += p.fastWriteField22(buf[offset:], w)
		offset += p.fastWriteField101(buf[offset:], w)
		offset += p.fastWriteField103(buf[offset:], w)
		offset += p.fastWriteField104(buf[offset:], w)
		offset += p.fastWriteField150(buf[offset:], w)
		offset += p.fastWriteField10(buf[offset:], w)
		offset += p.fastWriteField11(buf[offset:], w)
		offset += p.fastWriteField12(buf[offset:], w)
		offset += p.fastWriteField13(buf[offset:], w)
		offset += p.fastWriteField14(buf[offset:], w)
		offset += p.fastWriteField15(buf[offset:], w)
		offset += p.fastWriteField16(buf[offset:], w)
		offset += p.fastWriteField17(buf[offset:], w)
		offset += p.fastWriteField18(buf[offset:], w)
		offset += p.fastWriteField19(buf[offset:], w)
		offset += p.fastWriteField20(buf[offset:], w)
		offset += p.fastWriteField100(buf[offset:], w)
		offset += p.fastWriteField102(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *Dataset) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
		l += p.field16Length()
		l += p.field17Length()
		l += p.field18Length()
		l += p.field19Length()
		l += p.field20Length()
		l += p.field21Length()
		l += p.field22Length()
		l += p.field100Length()
		l += p.field101Length()
		l += p.field102Length()
		l += p.field103Length()
		l += p.field104Length()
		l += p.field150Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *Dataset) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.ID)
	return offset
}

func (p *Dataset) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAppID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 2)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.AppID)
	}
	return offset
}

func (p *Dataset) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 3)
	offset += thrift.Binary.WriteI64(buf[offset:], p.SpaceID)
	return offset
}

func (p *Dataset) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 4)
	offset += thrift.Binary.WriteI64(buf[offset:], p.SchemaID)
	return offset
}

func (p *Dataset) fastWriteField10(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 10)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *Dataset) fastWriteField11(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDescription() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 11)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Description)
	}
	return offset
}

func (p *Dataset) fastWriteField12(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetStatus() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 12)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.Status))
	}
	return offset
}

func (p *Dataset) fastWriteField13(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCategory() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 13)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.Category))
	}
	return offset
}

func (p *Dataset) fastWriteField14(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetBizCategory() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 14)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.BizCategory)
	}
	return offset
}

func (p *Dataset) fastWriteField15(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSchema() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 15)
		offset += p.Schema.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Dataset) fastWriteField16(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSecurityLevel() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 16)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.SecurityLevel))
	}
	return offset
}

func (p *Dataset) fastWriteField17(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetVisibility() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 17)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.Visibility))
	}
	return offset
}

func (p *Dataset) fastWriteField18(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSpec() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 18)
		offset += p.Spec.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Dataset) fastWriteField19(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFeatures() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 19)
		offset += p.Features.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Dataset) fastWriteField20(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetLatestVersion() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 20)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.LatestVersion)
	}
	return offset
}

func (p *Dataset) fastWriteField21(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetNextVersionNum() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 21)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.NextVersionNum)
	}
	return offset
}

func (p *Dataset) fastWriteField22(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetItemCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 22)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.ItemCount)
	}
	return offset
}

func (p *Dataset) fastWriteField100(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCreatedBy() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 100)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.CreatedBy)
	}
	return offset
}

func (p *Dataset) fastWriteField101(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCreatedAt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 101)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.CreatedAt)
	}
	return offset
}

func (p *Dataset) fastWriteField102(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetUpdatedBy() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 102)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.UpdatedBy)
	}
	return offset
}

func (p *Dataset) fastWriteField103(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetUpdatedAt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 103)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.UpdatedAt)
	}
	return offset
}

func (p *Dataset) fastWriteField104(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetExpiredAt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 104)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.ExpiredAt)
	}
	return offset
}

func (p *Dataset) fastWriteField150(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetChangeUncommitted() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 150)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.ChangeUncommitted)
	}
	return offset
}

func (p *Dataset) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *Dataset) field2Length() int {
	l := 0
	if p.IsSetAppID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *Dataset) field3Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *Dataset) field4Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *Dataset) field10Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *Dataset) field11Length() int {
	l := 0
	if p.IsSetDescription() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Description)
	}
	return l
}

func (p *Dataset) field12Length() int {
	l := 0
	if p.IsSetStatus() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *Dataset) field13Length() int {
	l := 0
	if p.IsSetCategory() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *Dataset) field14Length() int {
	l := 0
	if p.IsSetBizCategory() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.BizCategory)
	}
	return l
}

func (p *Dataset) field15Length() int {
	l := 0
	if p.IsSetSchema() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Schema.BLength()
	}
	return l
}

func (p *Dataset) field16Length() int {
	l := 0
	if p.IsSetSecurityLevel() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *Dataset) field17Length() int {
	l := 0
	if p.IsSetVisibility() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *Dataset) field18Length() int {
	l := 0
	if p.IsSetSpec() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Spec.BLength()
	}
	return l
}

func (p *Dataset) field19Length() int {
	l := 0
	if p.IsSetFeatures() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Features.BLength()
	}
	return l
}

func (p *Dataset) field20Length() int {
	l := 0
	if p.IsSetLatestVersion() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.LatestVersion)
	}
	return l
}

func (p *Dataset) field21Length() int {
	l := 0
	if p.IsSetNextVersionNum() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Dataset) field22Length() int {
	l := 0
	if p.IsSetItemCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Dataset) field100Length() int {
	l := 0
	if p.IsSetCreatedBy() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.CreatedBy)
	}
	return l
}

func (p *Dataset) field101Length() int {
	l := 0
	if p.IsSetCreatedAt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Dataset) field102Length() int {
	l := 0
	if p.IsSetUpdatedBy() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.UpdatedBy)
	}
	return l
}

func (p *Dataset) field103Length() int {
	l := 0
	if p.IsSetUpdatedAt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Dataset) field104Length() int {
	l := 0
	if p.IsSetExpiredAt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Dataset) field150Length() int {
	l := 0
	if p.IsSetChangeUncommitted() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *Dataset) DeepCopy(s interface{}) error {
	src, ok := s.(*Dataset)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.ID = src.ID

	if src.AppID != nil {
		tmp := *src.AppID
		p.AppID = &tmp
	}

	p.SpaceID = src.SpaceID

	p.SchemaID = src.SchemaID

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.Description != nil {
		var tmp string
		if *src.Description != "" {
			tmp = kutils.StringDeepCopy(*src.Description)
		}
		p.Description = &tmp
	}

	if src.Status != nil {
		tmp := *src.Status
		p.Status = &tmp
	}

	if src.Category != nil {
		tmp := *src.Category
		p.Category = &tmp
	}

	if src.BizCategory != nil {
		var tmp string
		if *src.BizCategory != "" {
			tmp = kutils.StringDeepCopy(*src.BizCategory)
		}
		p.BizCategory = &tmp
	}

	var _schema *DatasetSchema
	if src.Schema != nil {
		_schema = &DatasetSchema{}
		if err := _schema.DeepCopy(src.Schema); err != nil {
			return err
		}
	}
	p.Schema = _schema

	if src.SecurityLevel != nil {
		tmp := *src.SecurityLevel
		p.SecurityLevel = &tmp
	}

	if src.Visibility != nil {
		tmp := *src.Visibility
		p.Visibility = &tmp
	}

	var _spec *DatasetSpec
	if src.Spec != nil {
		_spec = &DatasetSpec{}
		if err := _spec.DeepCopy(src.Spec); err != nil {
			return err
		}
	}
	p.Spec = _spec

	var _features *DatasetFeatures
	if src.Features != nil {
		_features = &DatasetFeatures{}
		if err := _features.DeepCopy(src.Features); err != nil {
			return err
		}
	}
	p.Features = _features

	if src.LatestVersion != nil {
		var tmp string
		if *src.LatestVersion != "" {
			tmp = kutils.StringDeepCopy(*src.LatestVersion)
		}
		p.LatestVersion = &tmp
	}

	if src.NextVersionNum != nil {
		tmp := *src.NextVersionNum
		p.NextVersionNum = &tmp
	}

	if src.ItemCount != nil {
		tmp := *src.ItemCount
		p.ItemCount = &tmp
	}

	if src.CreatedBy != nil {
		var tmp string
		if *src.CreatedBy != "" {
			tmp = kutils.StringDeepCopy(*src.CreatedBy)
		}
		p.CreatedBy = &tmp
	}

	if src.CreatedAt != nil {
		tmp := *src.CreatedAt
		p.CreatedAt = &tmp
	}

	if src.UpdatedBy != nil {
		var tmp string
		if *src.UpdatedBy != "" {
			tmp = kutils.StringDeepCopy(*src.UpdatedBy)
		}
		p.UpdatedBy = &tmp
	}

	if src.UpdatedAt != nil {
		tmp := *src.UpdatedAt
		p.UpdatedAt = &tmp
	}

	if src.ExpiredAt != nil {
		tmp := *src.ExpiredAt
		p.ExpiredAt = &tmp
	}

	if src.ChangeUncommitted != nil {
		tmp := *src.ChangeUncommitted
		p.ChangeUncommitted = &tmp
	}

	return nil
}

func (p *DatasetSpec) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_DatasetSpec[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *DatasetSpec) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MaxItemCount = _field
	return offset, nil
}

func (p *DatasetSpec) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MaxFieldCount = _field
	return offset, nil
}

func (p *DatasetSpec) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MaxItemSize = _field
	return offset, nil
}

func (p *DatasetSpec) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MaxItemDataNestedDepth = _field
	return offset, nil
}

func (p *DatasetSpec) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *DatasetSpec) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *DatasetSpec) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *DatasetSpec) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMaxItemCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.MaxItemCount)
	}
	return offset
}

func (p *DatasetSpec) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMaxFieldCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 2)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.MaxFieldCount)
	}
	return offset
}

func (p *DatasetSpec) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMaxItemSize() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 3)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.MaxItemSize)
	}
	return offset
}

func (p *DatasetSpec) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMaxItemDataNestedDepth() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 4)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.MaxItemDataNestedDepth)
	}
	return offset
}

func (p *DatasetSpec) field1Length() int {
	l := 0
	if p.IsSetMaxItemCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetSpec) field2Length() int {
	l := 0
	if p.IsSetMaxFieldCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *DatasetSpec) field3Length() int {
	l := 0
	if p.IsSetMaxItemSize() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetSpec) field4Length() int {
	l := 0
	if p.IsSetMaxItemDataNestedDepth() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *DatasetSpec) DeepCopy(s interface{}) error {
	src, ok := s.(*DatasetSpec)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.MaxItemCount != nil {
		tmp := *src.MaxItemCount
		p.MaxItemCount = &tmp
	}

	if src.MaxFieldCount != nil {
		tmp := *src.MaxFieldCount
		p.MaxFieldCount = &tmp
	}

	if src.MaxItemSize != nil {
		tmp := *src.MaxItemSize
		p.MaxItemSize = &tmp
	}

	if src.MaxItemDataNestedDepth != nil {
		tmp := *src.MaxItemDataNestedDepth
		p.MaxItemDataNestedDepth = &tmp
	}

	return nil
}

func (p *DatasetVersion) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetID bool = false
	var issetSpaceID bool = false
	var issetDatasetID bool = false
	var issetSchemaID bool = false
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSpaceID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDatasetID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSchemaID = true
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 100:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField100(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 101:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField101(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 102:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField102(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	if !issetID {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetSpaceID {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetDatasetID {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetSchemaID {
		fieldId = 5
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_DatasetVersion[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
RequiredFieldNotSetError:
	return offset, thrift.NewProtocolException(thrift.INVALID_DATA, fmt.Sprintf("required field %s is not set", fieldIDToName_DatasetVersion[fieldId]))
}

func (p *DatasetVersion) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.ID = _field
	return offset, nil
}

func (p *DatasetVersion) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.AppID = _field
	return offset, nil
}

func (p *DatasetVersion) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.SpaceID = _field
	return offset, nil
}

func (p *DatasetVersion) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.DatasetID = _field
	return offset, nil
}

func (p *DatasetVersion) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = v
	}
	p.SchemaID = _field
	return offset, nil
}

func (p *DatasetVersion) FastReadField10(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Version = _field
	return offset, nil
}

func (p *DatasetVersion) FastReadField11(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.VersionNum = _field
	return offset, nil
}

func (p *DatasetVersion) FastReadField12(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Description = _field
	return offset, nil
}

func (p *DatasetVersion) FastReadField13(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.DatasetBrief = _field
	return offset, nil
}

func (p *DatasetVersion) FastReadField14(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ItemCount = _field
	return offset, nil
}

func (p *DatasetVersion) FastReadField15(buf []byte) (int, error) {
	offset := 0

	var _field *SnapshotStatus
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := SnapshotStatus(v)
		_field = &tmp
	}
	p.SnapshotStatus = _field
	return offset, nil
}

func (p *DatasetVersion) FastReadField100(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.CreatedBy = _field
	return offset, nil
}

func (p *DatasetVersion) FastReadField101(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.CreatedAt = _field
	return offset, nil
}

func (p *DatasetVersion) FastReadField102(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.DisabledAt = _field
	return offset, nil
}

func (p *DatasetVersion) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *DatasetVersion) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField11(buf[offset:], w)
		offset += p.fastWriteField14(buf[offset:], w)
		offset += p.fastWriteField101(buf[offset:], w)
		offset += p.fastWriteField102(buf[offset:], w)
		offset += p.fastWriteField10(buf[offset:], w)
		offset += p.fastWriteField12(buf[offset:], w)
		offset += p.fastWriteField13(buf[offset:], w)
		offset += p.fastWriteField15(buf[offset:], w)
		offset += p.fastWriteField100(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *DatasetVersion) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
		l += p.field100Length()
		l += p.field101Length()
		l += p.field102Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *DatasetVersion) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
	offset += thrift.Binary.WriteI64(buf[offset:], p.ID)
	return offset
}

func (p *DatasetVersion) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAppID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 2)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.AppID)
	}
	return offset
}

func (p *DatasetVersion) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 3)
	offset += thrift.Binary.WriteI64(buf[offset:], p.SpaceID)
	return offset
}

func (p *DatasetVersion) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 4)
	offset += thrift.Binary.WriteI64(buf[offset:], p.DatasetID)
	return offset
}

func (p *DatasetVersion) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 5)
	offset += thrift.Binary.WriteI64(buf[offset:], p.SchemaID)
	return offset
}

func (p *DatasetVersion) fastWriteField10(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetVersion() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 10)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Version)
	}
	return offset
}

func (p *DatasetVersion) fastWriteField11(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetVersionNum() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 11)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.VersionNum)
	}
	return offset
}

func (p *DatasetVersion) fastWriteField12(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDescription() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 12)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Description)
	}
	return offset
}

func (p *DatasetVersion) fastWriteField13(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDatasetBrief() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 13)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.DatasetBrief)
	}
	return offset
}

func (p *DatasetVersion) fastWriteField14(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetItemCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 14)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.ItemCount)
	}
	return offset
}

func (p *DatasetVersion) fastWriteField15(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSnapshotStatus() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 15)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.SnapshotStatus))
	}
	return offset
}

func (p *DatasetVersion) fastWriteField100(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCreatedBy() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 100)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.CreatedBy)
	}
	return offset
}

func (p *DatasetVersion) fastWriteField101(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCreatedAt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 101)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.CreatedAt)
	}
	return offset
}

func (p *DatasetVersion) fastWriteField102(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDisabledAt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 102)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.DisabledAt)
	}
	return offset
}

func (p *DatasetVersion) field1Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *DatasetVersion) field2Length() int {
	l := 0
	if p.IsSetAppID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *DatasetVersion) field3Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *DatasetVersion) field4Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *DatasetVersion) field5Length() int {
	l := 0
	l += thrift.Binary.FieldBeginLength()
	l += thrift.Binary.I64Length()
	return l
}

func (p *DatasetVersion) field10Length() int {
	l := 0
	if p.IsSetVersion() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Version)
	}
	return l
}

func (p *DatasetVersion) field11Length() int {
	l := 0
	if p.IsSetVersionNum() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetVersion) field12Length() int {
	l := 0
	if p.IsSetDescription() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Description)
	}
	return l
}

func (p *DatasetVersion) field13Length() int {
	l := 0
	if p.IsSetDatasetBrief() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.DatasetBrief)
	}
	return l
}

func (p *DatasetVersion) field14Length() int {
	l := 0
	if p.IsSetItemCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetVersion) field15Length() int {
	l := 0
	if p.IsSetSnapshotStatus() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *DatasetVersion) field100Length() int {
	l := 0
	if p.IsSetCreatedBy() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.CreatedBy)
	}
	return l
}

func (p *DatasetVersion) field101Length() int {
	l := 0
	if p.IsSetCreatedAt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetVersion) field102Length() int {
	l := 0
	if p.IsSetDisabledAt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetVersion) DeepCopy(s interface{}) error {
	src, ok := s.(*DatasetVersion)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	p.ID = src.ID

	if src.AppID != nil {
		tmp := *src.AppID
		p.AppID = &tmp
	}

	p.SpaceID = src.SpaceID

	p.DatasetID = src.DatasetID

	p.SchemaID = src.SchemaID

	if src.Version != nil {
		var tmp string
		if *src.Version != "" {
			tmp = kutils.StringDeepCopy(*src.Version)
		}
		p.Version = &tmp
	}

	if src.VersionNum != nil {
		tmp := *src.VersionNum
		p.VersionNum = &tmp
	}

	if src.Description != nil {
		var tmp string
		if *src.Description != "" {
			tmp = kutils.StringDeepCopy(*src.Description)
		}
		p.Description = &tmp
	}

	if src.DatasetBrief != nil {
		var tmp string
		if *src.DatasetBrief != "" {
			tmp = kutils.StringDeepCopy(*src.DatasetBrief)
		}
		p.DatasetBrief = &tmp
	}

	if src.ItemCount != nil {
		tmp := *src.ItemCount
		p.ItemCount = &tmp
	}

	if src.SnapshotStatus != nil {
		tmp := *src.SnapshotStatus
		p.SnapshotStatus = &tmp
	}

	if src.CreatedBy != nil {
		var tmp string
		if *src.CreatedBy != "" {
			tmp = kutils.StringDeepCopy(*src.CreatedBy)
		}
		p.CreatedBy = &tmp
	}

	if src.CreatedAt != nil {
		tmp := *src.CreatedAt
		p.CreatedAt = &tmp
	}

	if src.DisabledAt != nil {
		tmp := *src.DisabledAt
		p.DisabledAt = &tmp
	}

	return nil
}

func (p *DatasetSchema) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 100:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField100(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 101:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField101(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 102:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField102(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 103:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField103(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 104:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField104(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_DatasetSchema[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *DatasetSchema) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ID = _field
	return offset, nil
}

func (p *DatasetSchema) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.AppID = _field
	return offset, nil
}

func (p *DatasetSchema) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SpaceID = _field
	return offset, nil
}

func (p *DatasetSchema) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.DatasetID = _field
	return offset, nil
}

func (p *DatasetSchema) FastReadField10(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*FieldSchema, 0, size)
	values := make([]FieldSchema, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.Fields = _field
	return offset, nil
}

func (p *DatasetSchema) FastReadField11(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Immutable = _field
	return offset, nil
}

func (p *DatasetSchema) FastReadField100(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.CreatedBy = _field
	return offset, nil
}

func (p *DatasetSchema) FastReadField101(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.CreatedAt = _field
	return offset, nil
}

func (p *DatasetSchema) FastReadField102(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.UpdatedBy = _field
	return offset, nil
}

func (p *DatasetSchema) FastReadField103(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.UpdatedAt = _field
	return offset, nil
}

func (p *DatasetSchema) FastReadField104(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.UpdateVersion = _field
	return offset, nil
}

func (p *DatasetSchema) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *DatasetSchema) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField11(buf[offset:], w)
		offset += p.fastWriteField101(buf[offset:], w)
		offset += p.fastWriteField103(buf[offset:], w)
		offset += p.fastWriteField104(buf[offset:], w)
		offset += p.fastWriteField10(buf[offset:], w)
		offset += p.fastWriteField100(buf[offset:], w)
		offset += p.fastWriteField102(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *DatasetSchema) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field100Length()
		l += p.field101Length()
		l += p.field102Length()
		l += p.field103Length()
		l += p.field104Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *DatasetSchema) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.ID)
	}
	return offset
}

func (p *DatasetSchema) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAppID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 2)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.AppID)
	}
	return offset
}

func (p *DatasetSchema) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSpaceID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 3)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.SpaceID)
	}
	return offset
}

func (p *DatasetSchema) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDatasetID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 4)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.DatasetID)
	}
	return offset
}

func (p *DatasetSchema) fastWriteField10(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFields() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 10)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.Fields {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *DatasetSchema) fastWriteField11(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetImmutable() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 11)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.Immutable)
	}
	return offset
}

func (p *DatasetSchema) fastWriteField100(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCreatedBy() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 100)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.CreatedBy)
	}
	return offset
}

func (p *DatasetSchema) fastWriteField101(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCreatedAt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 101)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.CreatedAt)
	}
	return offset
}

func (p *DatasetSchema) fastWriteField102(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetUpdatedBy() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 102)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.UpdatedBy)
	}
	return offset
}

func (p *DatasetSchema) fastWriteField103(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetUpdatedAt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 103)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.UpdatedAt)
	}
	return offset
}

func (p *DatasetSchema) fastWriteField104(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetUpdateVersion() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 104)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.UpdateVersion)
	}
	return offset
}

func (p *DatasetSchema) field1Length() int {
	l := 0
	if p.IsSetID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetSchema) field2Length() int {
	l := 0
	if p.IsSetAppID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *DatasetSchema) field3Length() int {
	l := 0
	if p.IsSetSpaceID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetSchema) field4Length() int {
	l := 0
	if p.IsSetDatasetID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetSchema) field10Length() int {
	l := 0
	if p.IsSetFields() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.Fields {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *DatasetSchema) field11Length() int {
	l := 0
	if p.IsSetImmutable() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *DatasetSchema) field100Length() int {
	l := 0
	if p.IsSetCreatedBy() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.CreatedBy)
	}
	return l
}

func (p *DatasetSchema) field101Length() int {
	l := 0
	if p.IsSetCreatedAt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetSchema) field102Length() int {
	l := 0
	if p.IsSetUpdatedBy() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.UpdatedBy)
	}
	return l
}

func (p *DatasetSchema) field103Length() int {
	l := 0
	if p.IsSetUpdatedAt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetSchema) field104Length() int {
	l := 0
	if p.IsSetUpdateVersion() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetSchema) DeepCopy(s interface{}) error {
	src, ok := s.(*DatasetSchema)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ID != nil {
		tmp := *src.ID
		p.ID = &tmp
	}

	if src.AppID != nil {
		tmp := *src.AppID
		p.AppID = &tmp
	}

	if src.SpaceID != nil {
		tmp := *src.SpaceID
		p.SpaceID = &tmp
	}

	if src.DatasetID != nil {
		tmp := *src.DatasetID
		p.DatasetID = &tmp
	}

	if src.Fields != nil {
		p.Fields = make([]*FieldSchema, 0, len(src.Fields))
		for _, elem := range src.Fields {
			var _elem *FieldSchema
			if elem != nil {
				_elem = &FieldSchema{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.Fields = append(p.Fields, _elem)
		}
	}

	if src.Immutable != nil {
		tmp := *src.Immutable
		p.Immutable = &tmp
	}

	if src.CreatedBy != nil {
		var tmp string
		if *src.CreatedBy != "" {
			tmp = kutils.StringDeepCopy(*src.CreatedBy)
		}
		p.CreatedBy = &tmp
	}

	if src.CreatedAt != nil {
		tmp := *src.CreatedAt
		p.CreatedAt = &tmp
	}

	if src.UpdatedBy != nil {
		var tmp string
		if *src.UpdatedBy != "" {
			tmp = kutils.StringDeepCopy(*src.UpdatedBy)
		}
		p.UpdatedBy = &tmp
	}

	if src.UpdatedAt != nil {
		tmp := *src.UpdatedAt
		p.UpdatedAt = &tmp
	}

	if src.UpdateVersion != nil {
		tmp := *src.UpdateVersion
		p.UpdateVersion = &tmp
	}

	return nil
}

func (p *FieldSchema) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 20:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField20(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 21:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField21(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 50:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField50(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 51:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField51(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 55:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField55(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_FieldSchema[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *FieldSchema) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Key = _field
	return offset, nil
}

func (p *FieldSchema) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *FieldSchema) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Description = _field
	return offset, nil
}

func (p *FieldSchema) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *ContentType
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := ContentType(v)
		_field = &tmp
	}
	p.ContentType = _field
	return offset, nil
}

func (p *FieldSchema) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *FieldDisplayFormat
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := FieldDisplayFormat(v)
		_field = &tmp
	}
	p.DefaultFormat = _field
	return offset, nil
}

func (p *FieldSchema) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *SchemaKey
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := SchemaKey(v)
		_field = &tmp
	}
	p.SchemaKey = _field
	return offset, nil
}

func (p *FieldSchema) FastReadField20(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.TextSchema = _field
	return offset, nil
}

func (p *FieldSchema) FastReadField21(buf []byte) (int, error) {
	offset := 0
	_field := NewMultiModalSpec()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.MultiModelSpec = _field
	return offset, nil
}

func (p *FieldSchema) FastReadField50(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Hidden = _field
	return offset, nil
}

func (p *FieldSchema) FastReadField51(buf []byte) (int, error) {
	offset := 0

	var _field *FieldStatus
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := FieldStatus(v)
		_field = &tmp
	}
	p.Status = _field
	return offset, nil
}

func (p *FieldSchema) FastReadField55(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*FieldTransformationConfig, 0, size)
	values := make([]FieldTransformationConfig, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.DefaultTransformations = _field
	return offset, nil
}

func (p *FieldSchema) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *FieldSchema) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField50(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField20(buf[offset:], w)
		offset += p.fastWriteField21(buf[offset:], w)
		offset += p.fastWriteField51(buf[offset:], w)
		offset += p.fastWriteField55(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *FieldSchema) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field20Length()
		l += p.field21Length()
		l += p.field50Length()
		l += p.field51Length()
		l += p.field55Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *FieldSchema) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Key)
	}
	return offset
}

func (p *FieldSchema) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *FieldSchema) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDescription() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Description)
	}
	return offset
}

func (p *FieldSchema) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetContentType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 4)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.ContentType))
	}
	return offset
}

func (p *FieldSchema) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDefaultFormat() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 5)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.DefaultFormat))
	}
	return offset
}

func (p *FieldSchema) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSchemaKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 6)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.SchemaKey))
	}
	return offset
}

func (p *FieldSchema) fastWriteField20(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTextSchema() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 20)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.TextSchema)
	}
	return offset
}

func (p *FieldSchema) fastWriteField21(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMultiModelSpec() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 21)
		offset += p.MultiModelSpec.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *FieldSchema) fastWriteField50(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetHidden() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 50)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.Hidden)
	}
	return offset
}

func (p *FieldSchema) fastWriteField51(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetStatus() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 51)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.Status))
	}
	return offset
}

func (p *FieldSchema) fastWriteField55(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDefaultTransformations() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 55)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.DefaultTransformations {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *FieldSchema) field1Length() int {
	l := 0
	if p.IsSetKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Key)
	}
	return l
}

func (p *FieldSchema) field2Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *FieldSchema) field3Length() int {
	l := 0
	if p.IsSetDescription() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Description)
	}
	return l
}

func (p *FieldSchema) field4Length() int {
	l := 0
	if p.IsSetContentType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *FieldSchema) field5Length() int {
	l := 0
	if p.IsSetDefaultFormat() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *FieldSchema) field6Length() int {
	l := 0
	if p.IsSetSchemaKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *FieldSchema) field20Length() int {
	l := 0
	if p.IsSetTextSchema() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.TextSchema)
	}
	return l
}

func (p *FieldSchema) field21Length() int {
	l := 0
	if p.IsSetMultiModelSpec() {
		l += thrift.Binary.FieldBeginLength()
		l += p.MultiModelSpec.BLength()
	}
	return l
}

func (p *FieldSchema) field50Length() int {
	l := 0
	if p.IsSetHidden() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *FieldSchema) field51Length() int {
	l := 0
	if p.IsSetStatus() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *FieldSchema) field55Length() int {
	l := 0
	if p.IsSetDefaultTransformations() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.DefaultTransformations {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *FieldSchema) DeepCopy(s interface{}) error {
	src, ok := s.(*FieldSchema)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Key != nil {
		var tmp string
		if *src.Key != "" {
			tmp = kutils.StringDeepCopy(*src.Key)
		}
		p.Key = &tmp
	}

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.Description != nil {
		var tmp string
		if *src.Description != "" {
			tmp = kutils.StringDeepCopy(*src.Description)
		}
		p.Description = &tmp
	}

	if src.ContentType != nil {
		tmp := *src.ContentType
		p.ContentType = &tmp
	}

	if src.DefaultFormat != nil {
		tmp := *src.DefaultFormat
		p.DefaultFormat = &tmp
	}

	if src.SchemaKey != nil {
		tmp := *src.SchemaKey
		p.SchemaKey = &tmp
	}

	if src.TextSchema != nil {
		var tmp string
		if *src.TextSchema != "" {
			tmp = kutils.StringDeepCopy(*src.TextSchema)
		}
		p.TextSchema = &tmp
	}

	var _multiModelSpec *MultiModalSpec
	if src.MultiModelSpec != nil {
		_multiModelSpec = &MultiModalSpec{}
		if err := _multiModelSpec.DeepCopy(src.MultiModelSpec); err != nil {
			return err
		}
	}
	p.MultiModelSpec = _multiModelSpec

	if src.Hidden != nil {
		tmp := *src.Hidden
		p.Hidden = &tmp
	}

	if src.Status != nil {
		tmp := *src.Status
		p.Status = &tmp
	}

	if src.DefaultTransformations != nil {
		p.DefaultTransformations = make([]*FieldTransformationConfig, 0, len(src.DefaultTransformations))
		for _, elem := range src.DefaultTransformations {
			var _elem *FieldTransformationConfig
			if elem != nil {
				_elem = &FieldTransformationConfig{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.DefaultTransformations = append(p.DefaultTransformations, _elem)
		}
	}

	return nil
}

func (p *FieldTransformationConfig) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_FieldTransformationConfig[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *FieldTransformationConfig) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *FieldTransformationType
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := FieldTransformationType(v)
		_field = &tmp
	}
	p.TransType = _field
	return offset, nil
}

func (p *FieldTransformationConfig) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Global = _field
	return offset, nil
}

func (p *FieldTransformationConfig) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *FieldTransformationConfig) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *FieldTransformationConfig) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *FieldTransformationConfig) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTransType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 1)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.TransType))
	}
	return offset
}

func (p *FieldTransformationConfig) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetGlobal() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 2)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.Global)
	}
	return offset
}

func (p *FieldTransformationConfig) field1Length() int {
	l := 0
	if p.IsSetTransType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *FieldTransformationConfig) field2Length() int {
	l := 0
	if p.IsSetGlobal() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *FieldTransformationConfig) DeepCopy(s interface{}) error {
	src, ok := s.(*FieldTransformationConfig)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.TransType != nil {
		tmp := *src.TransType
		p.TransType = &tmp
	}

	if src.Global != nil {
		tmp := *src.Global
		p.Global = &tmp
	}

	return nil
}

func (p *MultiModalSpec) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_MultiModalSpec[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *MultiModalSpec) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MaxFileCount = _field
	return offset, nil
}

func (p *MultiModalSpec) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MaxFileSize = _field
	return offset, nil
}

func (p *MultiModalSpec) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_elem = v
		}

		_field = append(_field, _elem)
	}
	p.SupportedFormats = _field
	return offset, nil
}

func (p *MultiModalSpec) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *MultiModalSpec) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *MultiModalSpec) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *MultiModalSpec) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMaxFileCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.MaxFileCount)
	}
	return offset
}

func (p *MultiModalSpec) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMaxFileSize() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 2)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.MaxFileSize)
	}
	return offset
}

func (p *MultiModalSpec) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSupportedFormats() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 3)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.SupportedFormats {
			length++
			offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, v)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
	}
	return offset
}

func (p *MultiModalSpec) field1Length() int {
	l := 0
	if p.IsSetMaxFileCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *MultiModalSpec) field2Length() int {
	l := 0
	if p.IsSetMaxFileSize() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *MultiModalSpec) field3Length() int {
	l := 0
	if p.IsSetSupportedFormats() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.SupportedFormats {
			_ = v
			l += thrift.Binary.StringLengthNocopy(v)
		}
	}
	return l
}

func (p *MultiModalSpec) DeepCopy(s interface{}) error {
	src, ok := s.(*MultiModalSpec)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.MaxFileCount != nil {
		tmp := *src.MaxFileCount
		p.MaxFileCount = &tmp
	}

	if src.MaxFileSize != nil {
		tmp := *src.MaxFileSize
		p.MaxFileSize = &tmp
	}

	if src.SupportedFormats != nil {
		p.SupportedFormats = make([]string, 0, len(src.SupportedFormats))
		for _, elem := range src.SupportedFormats {
			var _elem string
			if elem != "" {
				_elem = kutils.StringDeepCopy(elem)
			}
			p.SupportedFormats = append(p.SupportedFormats, _elem)
		}
	}

	return nil
}

func (p *DatasetItem) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 100:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField100(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 101:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField101(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 102:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField102(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 103:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField103(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 150:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField150(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_DatasetItem[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *DatasetItem) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ID = _field
	return offset, nil
}

func (p *DatasetItem) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.AppID = _field
	return offset, nil
}

func (p *DatasetItem) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SpaceID = _field
	return offset, nil
}

func (p *DatasetItem) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.DatasetID = _field
	return offset, nil
}

func (p *DatasetItem) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SchemaID = _field
	return offset, nil
}

func (p *DatasetItem) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ItemID = _field
	return offset, nil
}

func (p *DatasetItem) FastReadField10(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ItemKey = _field
	return offset, nil
}

func (p *DatasetItem) FastReadField11(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*FieldData, 0, size)
	values := make([]FieldData, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.Data = _field
	return offset, nil
}

func (p *DatasetItem) FastReadField12(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*ItemData, 0, size)
	values := make([]ItemData, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.RepeatedData = _field
	return offset, nil
}

func (p *DatasetItem) FastReadField100(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.CreatedBy = _field
	return offset, nil
}

func (p *DatasetItem) FastReadField101(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.CreatedAt = _field
	return offset, nil
}

func (p *DatasetItem) FastReadField102(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.UpdatedBy = _field
	return offset, nil
}

func (p *DatasetItem) FastReadField103(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.UpdatedAt = _field
	return offset, nil
}

func (p *DatasetItem) FastReadField150(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.DataOmitted = _field
	return offset, nil
}

func (p *DatasetItem) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *DatasetItem) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField101(buf[offset:], w)
		offset += p.fastWriteField103(buf[offset:], w)
		offset += p.fastWriteField150(buf[offset:], w)
		offset += p.fastWriteField10(buf[offset:], w)
		offset += p.fastWriteField11(buf[offset:], w)
		offset += p.fastWriteField12(buf[offset:], w)
		offset += p.fastWriteField100(buf[offset:], w)
		offset += p.fastWriteField102(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *DatasetItem) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field100Length()
		l += p.field101Length()
		l += p.field102Length()
		l += p.field103Length()
		l += p.field150Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *DatasetItem) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.ID)
	}
	return offset
}

func (p *DatasetItem) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAppID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 2)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.AppID)
	}
	return offset
}

func (p *DatasetItem) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSpaceID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 3)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.SpaceID)
	}
	return offset
}

func (p *DatasetItem) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDatasetID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 4)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.DatasetID)
	}
	return offset
}

func (p *DatasetItem) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSchemaID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 5)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.SchemaID)
	}
	return offset
}

func (p *DatasetItem) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetItemID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 6)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.ItemID)
	}
	return offset
}

func (p *DatasetItem) fastWriteField10(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetItemKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 10)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ItemKey)
	}
	return offset
}

func (p *DatasetItem) fastWriteField11(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetData() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 11)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.Data {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *DatasetItem) fastWriteField12(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetRepeatedData() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 12)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.RepeatedData {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *DatasetItem) fastWriteField100(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCreatedBy() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 100)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.CreatedBy)
	}
	return offset
}

func (p *DatasetItem) fastWriteField101(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCreatedAt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 101)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.CreatedAt)
	}
	return offset
}

func (p *DatasetItem) fastWriteField102(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetUpdatedBy() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 102)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.UpdatedBy)
	}
	return offset
}

func (p *DatasetItem) fastWriteField103(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetUpdatedAt() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 103)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.UpdatedAt)
	}
	return offset
}

func (p *DatasetItem) fastWriteField150(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDataOmitted() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 150)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.DataOmitted)
	}
	return offset
}

func (p *DatasetItem) field1Length() int {
	l := 0
	if p.IsSetID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetItem) field2Length() int {
	l := 0
	if p.IsSetAppID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *DatasetItem) field3Length() int {
	l := 0
	if p.IsSetSpaceID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetItem) field4Length() int {
	l := 0
	if p.IsSetDatasetID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetItem) field5Length() int {
	l := 0
	if p.IsSetSchemaID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetItem) field6Length() int {
	l := 0
	if p.IsSetItemID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetItem) field10Length() int {
	l := 0
	if p.IsSetItemKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ItemKey)
	}
	return l
}

func (p *DatasetItem) field11Length() int {
	l := 0
	if p.IsSetData() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.Data {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *DatasetItem) field12Length() int {
	l := 0
	if p.IsSetRepeatedData() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.RepeatedData {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *DatasetItem) field100Length() int {
	l := 0
	if p.IsSetCreatedBy() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.CreatedBy)
	}
	return l
}

func (p *DatasetItem) field101Length() int {
	l := 0
	if p.IsSetCreatedAt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetItem) field102Length() int {
	l := 0
	if p.IsSetUpdatedBy() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.UpdatedBy)
	}
	return l
}

func (p *DatasetItem) field103Length() int {
	l := 0
	if p.IsSetUpdatedAt() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *DatasetItem) field150Length() int {
	l := 0
	if p.IsSetDataOmitted() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *DatasetItem) DeepCopy(s interface{}) error {
	src, ok := s.(*DatasetItem)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ID != nil {
		tmp := *src.ID
		p.ID = &tmp
	}

	if src.AppID != nil {
		tmp := *src.AppID
		p.AppID = &tmp
	}

	if src.SpaceID != nil {
		tmp := *src.SpaceID
		p.SpaceID = &tmp
	}

	if src.DatasetID != nil {
		tmp := *src.DatasetID
		p.DatasetID = &tmp
	}

	if src.SchemaID != nil {
		tmp := *src.SchemaID
		p.SchemaID = &tmp
	}

	if src.ItemID != nil {
		tmp := *src.ItemID
		p.ItemID = &tmp
	}

	if src.ItemKey != nil {
		var tmp string
		if *src.ItemKey != "" {
			tmp = kutils.StringDeepCopy(*src.ItemKey)
		}
		p.ItemKey = &tmp
	}

	if src.Data != nil {
		p.Data = make([]*FieldData, 0, len(src.Data))
		for _, elem := range src.Data {
			var _elem *FieldData
			if elem != nil {
				_elem = &FieldData{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.Data = append(p.Data, _elem)
		}
	}

	if src.RepeatedData != nil {
		p.RepeatedData = make([]*ItemData, 0, len(src.RepeatedData))
		for _, elem := range src.RepeatedData {
			var _elem *ItemData
			if elem != nil {
				_elem = &ItemData{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.RepeatedData = append(p.RepeatedData, _elem)
		}
	}

	if src.CreatedBy != nil {
		var tmp string
		if *src.CreatedBy != "" {
			tmp = kutils.StringDeepCopy(*src.CreatedBy)
		}
		p.CreatedBy = &tmp
	}

	if src.CreatedAt != nil {
		tmp := *src.CreatedAt
		p.CreatedAt = &tmp
	}

	if src.UpdatedBy != nil {
		var tmp string
		if *src.UpdatedBy != "" {
			tmp = kutils.StringDeepCopy(*src.UpdatedBy)
		}
		p.UpdatedBy = &tmp
	}

	if src.UpdatedAt != nil {
		tmp := *src.UpdatedAt
		p.UpdatedAt = &tmp
	}

	if src.DataOmitted != nil {
		tmp := *src.DataOmitted
		p.DataOmitted = &tmp
	}

	return nil
}

func (p *ItemData) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ItemData[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ItemData) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ID = _field
	return offset, nil
}

func (p *ItemData) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*FieldData, 0, size)
	values := make([]FieldData, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.Data = _field
	return offset, nil
}

func (p *ItemData) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ItemData) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ItemData) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ItemData) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.ID)
	}
	return offset
}

func (p *ItemData) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetData() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 2)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.Data {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *ItemData) field1Length() int {
	l := 0
	if p.IsSetID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *ItemData) field2Length() int {
	l := 0
	if p.IsSetData() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.Data {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *ItemData) DeepCopy(s interface{}) error {
	src, ok := s.(*ItemData)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ID != nil {
		tmp := *src.ID
		p.ID = &tmp
	}

	if src.Data != nil {
		p.Data = make([]*FieldData, 0, len(src.Data))
		for _, elem := range src.Data {
			var _elem *FieldData
			if elem != nil {
				_elem = &FieldData{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.Data = append(p.Data, _elem)
		}
	}

	return nil
}

func (p *FieldData) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_FieldData[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *FieldData) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Key = _field
	return offset, nil
}

func (p *FieldData) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *FieldData) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *ContentType
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := ContentType(v)
		_field = &tmp
	}
	p.ContentType = _field
	return offset, nil
}

func (p *FieldData) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Content = _field
	return offset, nil
}

func (p *FieldData) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*ObjectStorage, 0, size)
	values := make([]ObjectStorage, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.Attachments = _field
	return offset, nil
}

func (p *FieldData) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *FieldDisplayFormat
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := FieldDisplayFormat(v)
		_field = &tmp
	}
	p.Format = _field
	return offset, nil
}

func (p *FieldData) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*FieldData, 0, size)
	values := make([]FieldData, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.Parts = _field
	return offset, nil
}

func (p *FieldData) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *FieldData) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField7(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *FieldData) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *FieldData) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Key)
	}
	return offset
}

func (p *FieldData) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *FieldData) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetContentType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 3)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.ContentType))
	}
	return offset
}

func (p *FieldData) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetContent() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Content)
	}
	return offset
}

func (p *FieldData) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAttachments() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 5)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.Attachments {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *FieldData) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFormat() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 6)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.Format))
	}
	return offset
}

func (p *FieldData) fastWriteField7(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetParts() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 7)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.Parts {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *FieldData) field1Length() int {
	l := 0
	if p.IsSetKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Key)
	}
	return l
}

func (p *FieldData) field2Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *FieldData) field3Length() int {
	l := 0
	if p.IsSetContentType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *FieldData) field4Length() int {
	l := 0
	if p.IsSetContent() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Content)
	}
	return l
}

func (p *FieldData) field5Length() int {
	l := 0
	if p.IsSetAttachments() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.Attachments {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *FieldData) field6Length() int {
	l := 0
	if p.IsSetFormat() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *FieldData) field7Length() int {
	l := 0
	if p.IsSetParts() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.Parts {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *FieldData) DeepCopy(s interface{}) error {
	src, ok := s.(*FieldData)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Key != nil {
		var tmp string
		if *src.Key != "" {
			tmp = kutils.StringDeepCopy(*src.Key)
		}
		p.Key = &tmp
	}

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.ContentType != nil {
		tmp := *src.ContentType
		p.ContentType = &tmp
	}

	if src.Content != nil {
		var tmp string
		if *src.Content != "" {
			tmp = kutils.StringDeepCopy(*src.Content)
		}
		p.Content = &tmp
	}

	if src.Attachments != nil {
		p.Attachments = make([]*ObjectStorage, 0, len(src.Attachments))
		for _, elem := range src.Attachments {
			var _elem *ObjectStorage
			if elem != nil {
				_elem = &ObjectStorage{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.Attachments = append(p.Attachments, _elem)
		}
	}

	if src.Format != nil {
		tmp := *src.Format
		p.Format = &tmp
	}

	if src.Parts != nil {
		p.Parts = make([]*FieldData, 0, len(src.Parts))
		for _, elem := range src.Parts {
			var _elem *FieldData
			if elem != nil {
				_elem = &FieldData{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.Parts = append(p.Parts, _elem)
		}
	}

	return nil
}

func (p *ObjectStorage) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ObjectStorage[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ObjectStorage) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *StorageProvider
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := StorageProvider(v)
		_field = &tmp
	}
	p.Provider = _field
	return offset, nil
}

func (p *ObjectStorage) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *ObjectStorage) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.URI = _field
	return offset, nil
}

func (p *ObjectStorage) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.URL = _field
	return offset, nil
}

func (p *ObjectStorage) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ThumbURL = _field
	return offset, nil
}

func (p *ObjectStorage) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ObjectStorage) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ObjectStorage) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ObjectStorage) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProvider() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 1)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.Provider))
	}
	return offset
}

func (p *ObjectStorage) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *ObjectStorage) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetURI() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.URI)
	}
	return offset
}

func (p *ObjectStorage) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetURL() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.URL)
	}
	return offset
}

func (p *ObjectStorage) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetThumbURL() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 5)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ThumbURL)
	}
	return offset
}

func (p *ObjectStorage) field1Length() int {
	l := 0
	if p.IsSetProvider() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ObjectStorage) field2Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *ObjectStorage) field3Length() int {
	l := 0
	if p.IsSetURI() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.URI)
	}
	return l
}

func (p *ObjectStorage) field4Length() int {
	l := 0
	if p.IsSetURL() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.URL)
	}
	return l
}

func (p *ObjectStorage) field5Length() int {
	l := 0
	if p.IsSetThumbURL() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ThumbURL)
	}
	return l
}

func (p *ObjectStorage) DeepCopy(s interface{}) error {
	src, ok := s.(*ObjectStorage)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Provider != nil {
		tmp := *src.Provider
		p.Provider = &tmp
	}

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.URI != nil {
		var tmp string
		if *src.URI != "" {
			tmp = kutils.StringDeepCopy(*src.URI)
		}
		p.URI = &tmp
	}

	if src.URL != nil {
		var tmp string
		if *src.URL != "" {
			tmp = kutils.StringDeepCopy(*src.URL)
		}
		p.URL = &tmp
	}

	if src.ThumbURL != nil {
		var tmp string
		if *src.ThumbURL != "" {
			tmp = kutils.StringDeepCopy(*src.ThumbURL)
		}
		p.ThumbURL = &tmp
	}

	return nil
}

func (p *OrderBy) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_OrderBy[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *OrderBy) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Field = _field
	return offset, nil
}

func (p *OrderBy) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.IsAsc = _field
	return offset, nil
}

func (p *OrderBy) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *OrderBy) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *OrderBy) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *OrderBy) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetField() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Field)
	}
	return offset
}

func (p *OrderBy) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetIsAsc() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 2)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.IsAsc)
	}
	return offset
}

func (p *OrderBy) field1Length() int {
	l := 0
	if p.IsSetField() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Field)
	}
	return l
}

func (p *OrderBy) field2Length() int {
	l := 0
	if p.IsSetIsAsc() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *OrderBy) DeepCopy(s interface{}) error {
	src, ok := s.(*OrderBy)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Field != nil {
		var tmp string
		if *src.Field != "" {
			tmp = kutils.StringDeepCopy(*src.Field)
		}
		p.Field = &tmp
	}

	if src.IsAsc != nil {
		tmp := *src.IsAsc
		p.IsAsc = &tmp
	}

	return nil
}

func (p *FileUploadToken) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_FileUploadToken[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *FileUploadToken) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.AccessKeyID = _field
	return offset, nil
}

func (p *FileUploadToken) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SecretAccessKey = _field
	return offset, nil
}

func (p *FileUploadToken) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SessionToken = _field
	return offset, nil
}

func (p *FileUploadToken) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ExpiredTime = _field
	return offset, nil
}

func (p *FileUploadToken) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.CurrentTime = _field
	return offset, nil
}

func (p *FileUploadToken) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *FileUploadToken) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *FileUploadToken) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *FileUploadToken) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAccessKeyID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.AccessKeyID)
	}
	return offset
}

func (p *FileUploadToken) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSecretAccessKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.SecretAccessKey)
	}
	return offset
}

func (p *FileUploadToken) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSessionToken() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.SessionToken)
	}
	return offset
}

func (p *FileUploadToken) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetExpiredTime() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ExpiredTime)
	}
	return offset
}

func (p *FileUploadToken) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCurrentTime() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 5)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.CurrentTime)
	}
	return offset
}

func (p *FileUploadToken) field1Length() int {
	l := 0
	if p.IsSetAccessKeyID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.AccessKeyID)
	}
	return l
}

func (p *FileUploadToken) field2Length() int {
	l := 0
	if p.IsSetSecretAccessKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.SecretAccessKey)
	}
	return l
}

func (p *FileUploadToken) field3Length() int {
	l := 0
	if p.IsSetSessionToken() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.SessionToken)
	}
	return l
}

func (p *FileUploadToken) field4Length() int {
	l := 0
	if p.IsSetExpiredTime() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ExpiredTime)
	}
	return l
}

func (p *FileUploadToken) field5Length() int {
	l := 0
	if p.IsSetCurrentTime() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.CurrentTime)
	}
	return l
}

func (p *FileUploadToken) DeepCopy(s interface{}) error {
	src, ok := s.(*FileUploadToken)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.AccessKeyID != nil {
		var tmp string
		if *src.AccessKeyID != "" {
			tmp = kutils.StringDeepCopy(*src.AccessKeyID)
		}
		p.AccessKeyID = &tmp
	}

	if src.SecretAccessKey != nil {
		var tmp string
		if *src.SecretAccessKey != "" {
			tmp = kutils.StringDeepCopy(*src.SecretAccessKey)
		}
		p.SecretAccessKey = &tmp
	}

	if src.SessionToken != nil {
		var tmp string
		if *src.SessionToken != "" {
			tmp = kutils.StringDeepCopy(*src.SessionToken)
		}
		p.SessionToken = &tmp
	}

	if src.ExpiredTime != nil {
		var tmp string
		if *src.ExpiredTime != "" {
			tmp = kutils.StringDeepCopy(*src.ExpiredTime)
		}
		p.ExpiredTime = &tmp
	}

	if src.CurrentTime != nil {
		var tmp string
		if *src.CurrentTime != "" {
			tmp = kutils.StringDeepCopy(*src.CurrentTime)
		}
		p.CurrentTime = &tmp
	}

	return nil
}

func (p *ItemErrorDetail) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ItemErrorDetail[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ItemErrorDetail) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Message = _field
	return offset, nil
}

func (p *ItemErrorDetail) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Index = _field
	return offset, nil
}

func (p *ItemErrorDetail) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.StartIndex = _field
	return offset, nil
}

func (p *ItemErrorDetail) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EndIndex = _field
	return offset, nil
}

func (p *ItemErrorDetail) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ItemErrorDetail) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ItemErrorDetail) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ItemErrorDetail) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMessage() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Message)
	}
	return offset
}

func (p *ItemErrorDetail) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetIndex() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 2)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.Index)
	}
	return offset
}

func (p *ItemErrorDetail) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetStartIndex() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 3)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.StartIndex)
	}
	return offset
}

func (p *ItemErrorDetail) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEndIndex() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 4)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.EndIndex)
	}
	return offset
}

func (p *ItemErrorDetail) field1Length() int {
	l := 0
	if p.IsSetMessage() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Message)
	}
	return l
}

func (p *ItemErrorDetail) field2Length() int {
	l := 0
	if p.IsSetIndex() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ItemErrorDetail) field3Length() int {
	l := 0
	if p.IsSetStartIndex() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ItemErrorDetail) field4Length() int {
	l := 0
	if p.IsSetEndIndex() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ItemErrorDetail) DeepCopy(s interface{}) error {
	src, ok := s.(*ItemErrorDetail)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Message != nil {
		var tmp string
		if *src.Message != "" {
			tmp = kutils.StringDeepCopy(*src.Message)
		}
		p.Message = &tmp
	}

	if src.Index != nil {
		tmp := *src.Index
		p.Index = &tmp
	}

	if src.StartIndex != nil {
		tmp := *src.StartIndex
		p.StartIndex = &tmp
	}

	if src.EndIndex != nil {
		tmp := *src.EndIndex
		p.EndIndex = &tmp
	}

	return nil
}

func (p *ItemErrorGroup) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ItemErrorGroup[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ItemErrorGroup) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *ItemErrorType
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := ItemErrorType(v)
		_field = &tmp
	}
	p.Type = _field
	return offset, nil
}

func (p *ItemErrorGroup) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Summary = _field
	return offset, nil
}

func (p *ItemErrorGroup) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ErrorCount = _field
	return offset, nil
}

func (p *ItemErrorGroup) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*ItemErrorDetail, 0, size)
	values := make([]ItemErrorDetail, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.Details = _field
	return offset, nil
}

func (p *ItemErrorGroup) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ItemErrorGroup) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ItemErrorGroup) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ItemErrorGroup) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 1)
		offset += thrift.Binary.WriteI32(buf[offset:], int32(*p.Type))
	}
	return offset
}

func (p *ItemErrorGroup) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSummary() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Summary)
	}
	return offset
}

func (p *ItemErrorGroup) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetErrorCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 3)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.ErrorCount)
	}
	return offset
}

func (p *ItemErrorGroup) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDetails() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 4)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.Details {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *ItemErrorGroup) field1Length() int {
	l := 0
	if p.IsSetType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ItemErrorGroup) field2Length() int {
	l := 0
	if p.IsSetSummary() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Summary)
	}
	return l
}

func (p *ItemErrorGroup) field3Length() int {
	l := 0
	if p.IsSetErrorCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ItemErrorGroup) field4Length() int {
	l := 0
	if p.IsSetDetails() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.Details {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *ItemErrorGroup) DeepCopy(s interface{}) error {
	src, ok := s.(*ItemErrorGroup)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Type != nil {
		tmp := *src.Type
		p.Type = &tmp
	}

	if src.Summary != nil {
		var tmp string
		if *src.Summary != "" {
			tmp = kutils.StringDeepCopy(*src.Summary)
		}
		p.Summary = &tmp
	}

	if src.ErrorCount != nil {
		tmp := *src.ErrorCount
		p.ErrorCount = &tmp
	}

	if src.Details != nil {
		p.Details = make([]*ItemErrorDetail, 0, len(src.Details))
		for _, elem := range src.Details {
			var _elem *ItemErrorDetail
			if elem != nil {
				_elem = &ItemErrorDetail{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.Details = append(p.Details, _elem)
		}
	}

	return nil
}
