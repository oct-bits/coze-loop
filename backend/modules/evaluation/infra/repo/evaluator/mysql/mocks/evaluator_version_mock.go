// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql (interfaces: EvaluatorVersionDAO)

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	db "github.com/coze-dev/coze-loop/backend/infra/db"
	mysql "github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql"
	model "github.com/coze-dev/coze-loop/backend/modules/evaluation/infra/repo/evaluator/mysql/gorm_gen/model"
	"go.uber.org/mock/gomock"
)

// MockEvaluatorVersionDAO is a mock of EvaluatorVersionDAO interface.
type MockEvaluatorVersionDAO struct {
	ctrl     *gomock.Controller
	recorder *MockEvaluatorVersionDAOMockRecorder
}

// MockEvaluatorVersionDAOMockRecorder is the mock recorder for MockEvaluatorVersionDAO.
type MockEvaluatorVersionDAOMockRecorder struct {
	mock *MockEvaluatorVersionDAO
}

// NewMockEvaluatorVersionDAO creates a new mock instance.
func NewMockEvaluatorVersionDAO(ctrl *gomock.Controller) *MockEvaluatorVersionDAO {
	mock := &MockEvaluatorVersionDAO{ctrl: ctrl}
	mock.recorder = &MockEvaluatorVersionDAOMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEvaluatorVersionDAO) EXPECT() *MockEvaluatorVersionDAOMockRecorder {
	return m.recorder
}

// BatchDeleteEvaluatorVersionByEvaluatorIDs mocks base method.
func (m *MockEvaluatorVersionDAO) BatchDeleteEvaluatorVersionByEvaluatorIDs(arg0 context.Context, arg1 []int64, arg2 string, arg3 ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchDeleteEvaluatorVersionByEvaluatorIDs", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchDeleteEvaluatorVersionByEvaluatorIDs indicates an expected call of BatchDeleteEvaluatorVersionByEvaluatorIDs.
func (mr *MockEvaluatorVersionDAOMockRecorder) BatchDeleteEvaluatorVersionByEvaluatorIDs(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchDeleteEvaluatorVersionByEvaluatorIDs", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).BatchDeleteEvaluatorVersionByEvaluatorIDs), varargs...)
}

// BatchGetEvaluatorDraftByEvaluatorID mocks base method.
func (m *MockEvaluatorVersionDAO) BatchGetEvaluatorDraftByEvaluatorID(arg0 context.Context, arg1 []int64, arg2 bool, arg3 ...db.Option) ([]*model.EvaluatorVersion, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetEvaluatorDraftByEvaluatorID", varargs...)
	ret0, _ := ret[0].([]*model.EvaluatorVersion)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetEvaluatorDraftByEvaluatorID indicates an expected call of BatchGetEvaluatorDraftByEvaluatorID.
func (mr *MockEvaluatorVersionDAOMockRecorder) BatchGetEvaluatorDraftByEvaluatorID(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetEvaluatorDraftByEvaluatorID", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).BatchGetEvaluatorDraftByEvaluatorID), varargs...)
}

// BatchGetEvaluatorVersionByID mocks base method.
func (m *MockEvaluatorVersionDAO) BatchGetEvaluatorVersionByID(arg0 context.Context, arg1 *int64, arg2 []int64, arg3 bool, arg4 ...db.Option) ([]*model.EvaluatorVersion, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetEvaluatorVersionByID", varargs...)
	ret0, _ := ret[0].([]*model.EvaluatorVersion)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetEvaluatorVersionByID indicates an expected call of BatchGetEvaluatorVersionByID.
func (mr *MockEvaluatorVersionDAOMockRecorder) BatchGetEvaluatorVersionByID(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetEvaluatorVersionByID", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).BatchGetEvaluatorVersionByID), varargs...)
}

// BatchGetEvaluatorVersionsByEvaluatorIDs mocks base method.
func (m *MockEvaluatorVersionDAO) BatchGetEvaluatorVersionsByEvaluatorIDs(arg0 context.Context, arg1 []int64, arg2 bool, arg3 ...db.Option) ([]*model.EvaluatorVersion, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchGetEvaluatorVersionsByEvaluatorIDs", varargs...)
	ret0, _ := ret[0].([]*model.EvaluatorVersion)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchGetEvaluatorVersionsByEvaluatorIDs indicates an expected call of BatchGetEvaluatorVersionsByEvaluatorIDs.
func (mr *MockEvaluatorVersionDAOMockRecorder) BatchGetEvaluatorVersionsByEvaluatorIDs(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchGetEvaluatorVersionsByEvaluatorIDs", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).BatchGetEvaluatorVersionsByEvaluatorIDs), varargs...)
}

// CheckVersionExist mocks base method.
func (m *MockEvaluatorVersionDAO) CheckVersionExist(arg0 context.Context, arg1 int64, arg2 string, arg3 ...db.Option) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CheckVersionExist", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckVersionExist indicates an expected call of CheckVersionExist.
func (mr *MockEvaluatorVersionDAOMockRecorder) CheckVersionExist(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckVersionExist", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).CheckVersionExist), varargs...)
}

// CreateEvaluatorVersion mocks base method.
func (m *MockEvaluatorVersionDAO) CreateEvaluatorVersion(arg0 context.Context, arg1 *model.EvaluatorVersion, arg2 ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateEvaluatorVersion", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateEvaluatorVersion indicates an expected call of CreateEvaluatorVersion.
func (mr *MockEvaluatorVersionDAOMockRecorder) CreateEvaluatorVersion(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateEvaluatorVersion", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).CreateEvaluatorVersion), varargs...)
}

// DeleteEvaluatorVersion mocks base method.
func (m *MockEvaluatorVersionDAO) DeleteEvaluatorVersion(arg0 context.Context, arg1 int64, arg2 string, arg3 ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteEvaluatorVersion", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteEvaluatorVersion indicates an expected call of DeleteEvaluatorVersion.
func (mr *MockEvaluatorVersionDAOMockRecorder) DeleteEvaluatorVersion(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEvaluatorVersion", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).DeleteEvaluatorVersion), varargs...)
}

// ListEvaluatorVersion mocks base method.
func (m *MockEvaluatorVersionDAO) ListEvaluatorVersion(arg0 context.Context, arg1 *mysql.ListEvaluatorVersionRequest, arg2 ...db.Option) (*mysql.ListEvaluatorVersionResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListEvaluatorVersion", varargs...)
	ret0, _ := ret[0].(*mysql.ListEvaluatorVersionResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListEvaluatorVersion indicates an expected call of ListEvaluatorVersion.
func (mr *MockEvaluatorVersionDAOMockRecorder) ListEvaluatorVersion(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListEvaluatorVersion", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).ListEvaluatorVersion), varargs...)
}

// UpdateEvaluatorDraft mocks base method.
func (m *MockEvaluatorVersionDAO) UpdateEvaluatorDraft(arg0 context.Context, arg1 *model.EvaluatorVersion, arg2 ...db.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateEvaluatorDraft", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateEvaluatorDraft indicates an expected call of UpdateEvaluatorDraft.
func (mr *MockEvaluatorVersionDAOMockRecorder) UpdateEvaluatorDraft(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEvaluatorDraft", reflect.TypeOf((*MockEvaluatorVersionDAO)(nil).UpdateEvaluatorDraft), varargs...)
}
