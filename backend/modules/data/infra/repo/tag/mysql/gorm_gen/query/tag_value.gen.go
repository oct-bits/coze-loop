// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/coze-dev/coze-loop/backend/modules/data/infra/repo/tag/mysql/gorm_gen/model"
)

func newTagValue(db *gorm.DB, opts ...gen.DOOption) tagValue {
	_tagValue := tagValue{}

	_tagValue.tagValueDo.UseDB(db, opts...)
	_tagValue.tagValueDo.UseModel(&model.TagValue{})

	tableName := _tagValue.tagValueDo.TableName()
	_tagValue.ALL = field.NewAsterisk(tableName)
	_tagValue.ID = field.NewInt64(tableName, "id")
	_tagValue.AppID = field.NewInt32(tableName, "app_id")
	_tagValue.SpaceID = field.NewInt64(tableName, "space_id")
	_tagValue.TagKeyID = field.NewInt64(tableName, "tag_key_id")
	_tagValue.TagValueID = field.NewInt64(tableName, "tag_value_id")
	_tagValue.TagValueName = field.NewString(tableName, "tag_value_name")
	_tagValue.Description = field.NewString(tableName, "description")
	_tagValue.ParentValueID = field.NewInt64(tableName, "parent_value_id")
	_tagValue.CreatedAt = field.NewTime(tableName, "created_at")
	_tagValue.UpdatedAt = field.NewTime(tableName, "updated_at")
	_tagValue.VersionNum = field.NewInt32(tableName, "version_num")
	_tagValue.Status = field.NewString(tableName, "status")
	_tagValue.CreatedBy = field.NewString(tableName, "created_by")
	_tagValue.UpdatedBy = field.NewString(tableName, "updated_by")

	_tagValue.fillFieldMap()

	return _tagValue
}

// tagValue tag value元数据表
type tagValue struct {
	tagValueDo tagValueDo

	ALL           field.Asterisk
	ID            field.Int64  // 主键id
	AppID         field.Int32  // application id
	SpaceID       field.Int64  // 归属space id,做分片键
	TagKeyID      field.Int64  // tag id，唯一标识一个标签
	TagValueID    field.Int64  // tag value id，唯一标识一个标签
	TagValueName  field.String // tag value名称
	Description   field.String // tag value描述
	ParentValueID field.Int64  // 级联标签场景,上层tag value id
	CreatedAt     field.Time   // 创建时间
	UpdatedAt     field.Time   // 更新时间
	VersionNum    field.Int32  // tag自增版本
	Status        field.String // 状态,active,inactive,deprecated
	CreatedBy     field.String // 创建者
	UpdatedBy     field.String // 更新者

	fieldMap map[string]field.Expr
}

func (t tagValue) Table(newTableName string) *tagValue {
	t.tagValueDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tagValue) As(alias string) *tagValue {
	t.tagValueDo.DO = *(t.tagValueDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tagValue) updateTableName(table string) *tagValue {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.AppID = field.NewInt32(table, "app_id")
	t.SpaceID = field.NewInt64(table, "space_id")
	t.TagKeyID = field.NewInt64(table, "tag_key_id")
	t.TagValueID = field.NewInt64(table, "tag_value_id")
	t.TagValueName = field.NewString(table, "tag_value_name")
	t.Description = field.NewString(table, "description")
	t.ParentValueID = field.NewInt64(table, "parent_value_id")
	t.CreatedAt = field.NewTime(table, "created_at")
	t.UpdatedAt = field.NewTime(table, "updated_at")
	t.VersionNum = field.NewInt32(table, "version_num")
	t.Status = field.NewString(table, "status")
	t.CreatedBy = field.NewString(table, "created_by")
	t.UpdatedBy = field.NewString(table, "updated_by")

	t.fillFieldMap()

	return t
}

func (t *tagValue) WithContext(ctx context.Context) *tagValueDo { return t.tagValueDo.WithContext(ctx) }

func (t tagValue) TableName() string { return t.tagValueDo.TableName() }

func (t tagValue) Alias() string { return t.tagValueDo.Alias() }

func (t tagValue) Columns(cols ...field.Expr) gen.Columns { return t.tagValueDo.Columns(cols...) }

func (t *tagValue) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tagValue) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 14)
	t.fieldMap["id"] = t.ID
	t.fieldMap["app_id"] = t.AppID
	t.fieldMap["space_id"] = t.SpaceID
	t.fieldMap["tag_key_id"] = t.TagKeyID
	t.fieldMap["tag_value_id"] = t.TagValueID
	t.fieldMap["tag_value_name"] = t.TagValueName
	t.fieldMap["description"] = t.Description
	t.fieldMap["parent_value_id"] = t.ParentValueID
	t.fieldMap["created_at"] = t.CreatedAt
	t.fieldMap["updated_at"] = t.UpdatedAt
	t.fieldMap["version_num"] = t.VersionNum
	t.fieldMap["status"] = t.Status
	t.fieldMap["created_by"] = t.CreatedBy
	t.fieldMap["updated_by"] = t.UpdatedBy
}

func (t tagValue) clone(db *gorm.DB) tagValue {
	t.tagValueDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tagValue) replaceDB(db *gorm.DB) tagValue {
	t.tagValueDo.ReplaceDB(db)
	return t
}

type tagValueDo struct{ gen.DO }

func (t tagValueDo) Debug() *tagValueDo {
	return t.withDO(t.DO.Debug())
}

func (t tagValueDo) WithContext(ctx context.Context) *tagValueDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tagValueDo) ReadDB() *tagValueDo {
	return t.Clauses(dbresolver.Read)
}

func (t tagValueDo) WriteDB() *tagValueDo {
	return t.Clauses(dbresolver.Write)
}

func (t tagValueDo) Session(config *gorm.Session) *tagValueDo {
	return t.withDO(t.DO.Session(config))
}

func (t tagValueDo) Clauses(conds ...clause.Expression) *tagValueDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tagValueDo) Returning(value interface{}, columns ...string) *tagValueDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tagValueDo) Not(conds ...gen.Condition) *tagValueDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tagValueDo) Or(conds ...gen.Condition) *tagValueDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tagValueDo) Select(conds ...field.Expr) *tagValueDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tagValueDo) Where(conds ...gen.Condition) *tagValueDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tagValueDo) Order(conds ...field.Expr) *tagValueDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tagValueDo) Distinct(cols ...field.Expr) *tagValueDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tagValueDo) Omit(cols ...field.Expr) *tagValueDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tagValueDo) Join(table schema.Tabler, on ...field.Expr) *tagValueDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tagValueDo) LeftJoin(table schema.Tabler, on ...field.Expr) *tagValueDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tagValueDo) RightJoin(table schema.Tabler, on ...field.Expr) *tagValueDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tagValueDo) Group(cols ...field.Expr) *tagValueDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tagValueDo) Having(conds ...gen.Condition) *tagValueDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tagValueDo) Limit(limit int) *tagValueDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tagValueDo) Offset(offset int) *tagValueDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tagValueDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *tagValueDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tagValueDo) Unscoped() *tagValueDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tagValueDo) Create(values ...*model.TagValue) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tagValueDo) CreateInBatches(values []*model.TagValue, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tagValueDo) Save(values ...*model.TagValue) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tagValueDo) First() (*model.TagValue, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TagValue), nil
	}
}

func (t tagValueDo) Take() (*model.TagValue, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TagValue), nil
	}
}

func (t tagValueDo) Last() (*model.TagValue, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TagValue), nil
	}
}

func (t tagValueDo) Find() ([]*model.TagValue, error) {
	result, err := t.DO.Find()
	return result.([]*model.TagValue), err
}

func (t tagValueDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TagValue, err error) {
	buf := make([]*model.TagValue, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tagValueDo) FindInBatches(result *[]*model.TagValue, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tagValueDo) Attrs(attrs ...field.AssignExpr) *tagValueDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tagValueDo) Assign(attrs ...field.AssignExpr) *tagValueDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tagValueDo) Joins(fields ...field.RelationField) *tagValueDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tagValueDo) Preload(fields ...field.RelationField) *tagValueDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tagValueDo) FirstOrInit() (*model.TagValue, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TagValue), nil
	}
}

func (t tagValueDo) FirstOrCreate() (*model.TagValue, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TagValue), nil
	}
}

func (t tagValueDo) FindByPage(offset int, limit int) (result []*model.TagValue, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tagValueDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tagValueDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tagValueDo) Delete(models ...*model.TagValue) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tagValueDo) withDO(do gen.Dao) *tagValueDo {
	t.DO = *do.(*gen.DO)
	return t
}
